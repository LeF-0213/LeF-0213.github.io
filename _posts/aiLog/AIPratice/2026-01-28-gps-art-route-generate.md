---
layout: post
related_posts:
  - /aiLog/AIPractice
title:  "GPS 아트 경로 생성 트러블 슈팅 - Week 1 (1/28~1/31)"
date:   2026-01-28
categories:
  - aiPratice
description: >
    🏁 개발 목표: 사용자가 그린 SVG 자유곡선을 지도 데이터(OSMnx)와 매칭하여, 실제 걸을 수 있는 산책로로 변환하는 알고리즘을 개발
---
* toc
{:toc .large-only}

## 1월 28일 - 초기 구현 완료

### 완료한 작업

**자동 그림 경로 생성 초기 구현 완료**

<div style="display: flex; gap: 10px">
<img width="100%" alt="Image" src="https://github.com/user-attachments/assets/e6ab6428-c60b-484a-88a7-3ececf5f73ac" />

<img width="100%" alt="Image" src="https://github.com/user-attachments/assets/d5012862-d2db-4e95-ae10-0f03d32d9829" />
</div>

- 총 길이 및 예외에 대한 validation 값도 반환
- OSMnx 라이브러리를 이용해 받은 보행자 도로에 대한 노드들을 받아 생성한 경로를 카카오 지도 위에 다시 그림
- 원본 그림도 함께 보이게 하여 그림 경로가 제대로 그려지고 있는지 확인 할 수 있게 함

### 어려웠던 점

**관련 논문 리뷰**

[Automatic route plannig for GPS art generation](../PaperReview/2026-01-20-Automatic-route-planning-for-GPS-art-generation.md)

- 논문을 구현할 때 논문에 쓰인 수식이 잘못 표기되어있어 헤메는 과정이 있었음
  - **잘못된 수식**   
    
    $$C(\vec{P}, \vec{N}, \vec{S}, \vec{E}) = \alpha \cdot C_1(\vec{N}, \vec{E}) + \beta \cdot C_2(\vec{P}, \vec{N}) + \gamma \cdot C_3(\vec{P}, \vec{N}, \vec{S}, \vec{E})$$
  - **바꾼 수식**    
         
    $$C(\vec{P}, \vec{N}, \vec{S}, \vec{E}) = \alpha \cdot C_1(\vec{S}, \vec{E}) + \beta \cdot C_2(\vec{P}, \vec{N}) + \gamma \cdot C_3(\vec{P}, \vec{N}, \vec{S}, \vec{E})$$
- 사용자가 그린 그림을 사용자가 원하는 산책 길이만큼 반영하기 위해 스케일 값을 도입
- 3가지 경로를 그리기 위해 각각 알파, 베타, 감마의 가중치 값을 얼마나 주어야 할지 고민

### 현재 문제점

- 경로 생성 시 불필요한 경로가 함께 생성됨
- 실제 프론트와 연계시 'SVG 형식의 경로 데이터' 즉 문자열 타입으로 받아오기에,          
  `문자열 -> 픽셀 좌표 -> 지도 좌표`로 변경하는 단계를 거쳐 사용자가 그린 경로를 처리해야 한다.
- 경로의 가중치 값을 각각 어느 정도로 주어야 최대한 사용자가 만족할만한 경로가 짜여질 지 고민
  - 알파 ($\alpha$): 목적지 지향성 가중치 ($C_1$)
    - 최종 목적지($E$)에 얼마나 빨리 도달할지
  - 베타 ($\beta$): 이동 효율성 가중치 ($C_2$)
    - 실제 도로 주행 거리를 얼마나 짧게 유지할지(도로 엣지의 물리적 길이 최소화)
  - 감마 ($\gamma$): 형상 유사도 가중치 ($C_3$) - 가장 중요
    - 사용자가 그린 그림과 실제 경로가 얼마나 똑같이 생겼는지
- 현재는 그림의 중심을 출발지로 잡아 경로를 그리는데,          
  경로 상의 한 점으로 출발지를 옮겨야 더 유사한 경로를 생성할 수 있을 것 같다.

### 앞으로 해결해야 할 점

- 그림에 스케일뿐만 아니라 로테이션도 적용하여 최대한 사용자가 만족할 만한 그림 경로를 생성해낼 수 있도록 해야 함
- 사용자가 svg로 그린 값을 픽셀 좌표로 -> 지도 좌표로 변경하여 경로를 json으로 반환할 수 있는 과정이 필요
- 그림을 중심으로 출발지를 잡는 것이 아닌, 출발지가 경로 상의 한 점이 되게 하여 최대한 다양한 경로가 나올 수 있게끔 방향을 잡음
- 경로의 유사도를 평가하여 사용자가 정확도, 거리순 등으로 더 명확하게 선택할 수 있게 해야 한다.
- 원본 그림에도 스케일을 적용하여 한눈에 보기 쉽게 한다.

### 데이터 처리 파이프 라인

```
SVG 경로 문자열
    ↓ parse_svg_path_to_canvas_coordinates
Canvas 좌표 [{"x": 175, "y": 350}, ...]
    ↓ convert_canvas_to_geographic
지리 좌표 [{"lat": 37.5, "lon": 127.0}, ...]
    ↓ rotate_coordinates (선택적)
회전된 지리 좌표
    ↓ scale_drawing_coordinates
스케일링된 지리 좌표
    ↓ find_paths
생성된 경로
    ↓ calculate_route_similarity
유사도 점수
```

<br />

---

## 1월 29일 - 회전 및 스케일링 개선

### 문제점

- 여전히 그림과 많이 유사하지 않음
- 가중치를 조절해보았으나, 감마 값이 3.0이나 5.0이나 10.0이나 별반 다르지 않음
- n_samples 즉, 그림 선분을 나누는 점을 더 많이 찍어 노드를 더 유사하게 따라갈 수 있게          
20 -> 50 -> 100으로 늘려보았으나 차이가 없었음

### A* vs Dijkstra 문제

- 속도를 위해 목적지가지의 거리를 먼저보는 A*를 사용했는데,       
그게 모양이 제대로 나오지 않은 원인인 것 같다. 
- 즉, A*를 썼을 때는 C3 비용이 아무리 커도 목적지가 가깝다면            
그곳이 우선이 되어버리는 문제가 발생할 가능성이 높음. (휴리스틱 값을 사용하기 때문)
- 반면, 다익스트라는 지금까지 쌓인 비용만 보고 판단하기에 C3가 잘 반영될 수 있음
- 논문에서도 다익스트라 기반을 사용하고 있음

> **그러나** 이론상 다익스트라로 바꾸는 것이 정답인 것 같았지만,      
> 그려지는 그림 경로 상의 변화는 없었다.
> 오히려 로테이션 값을 좀 더 촘촘하게(10도 마다) 측정하게 바꾸니 유의미한 변화가 생겼다.

### 해결한 일

<img width="100%" alt="Image" src="https://github.com/user-attachments/assets/54f69bbc-ba8b-45f0-b953-4b8391999055" />

- 원본 파일도 함께 사용자가 원하는 거리만큼 스케일링 적용
- svg 형식을 canvas 좌표 -> 지리 좌표로 변환 성공
- 로테이션을 조절하여 각각의 로테이션 중 가장 유사도가 비슷한 것을 선별하고, 그 중에서도 최종 3개를 선택함.

<br />

---

## 1월 30일 - 성능 문제 및 경로 길이 피드백 시스템 도입

### 문제점 분석

1. 경로 생성 속도 문제
  - 3km, 5km, 10km 정도의 그림 경로를 그려달라고 했을 때,         
  각각 30.49 ~ 56.69초, 106.95초, 396.24초 등이 걸림
2. 경로 길이 편차 문제
  - 생성하고자 했던 경로가 **5km** 정도라면 생성된 경로는 **8km** 등 경로 길이의 편차가 너무 커지는 경우가 발생
3. 한국 도시의 특수성
  - 실제 한국 도시는 체크패턴이 심해서 생각했던 것처럼 곡선 경도가 잘 나오지 않음
  - 논문의 다익스트라 기반 커스텀 비용 함수 말고도,     
  **스케일・회전된 원본 도형의 포인트들을 먼저 실제 도로 위 노드 중 가장 가까운 노드에 붙이고, 결정된 노드들을 차례로 이어주는 방식       
  (즉, 도형의 정점을 웨이포인트로 전환하는 방식)**
4. 출발지 문제
  - 출발지를 시작과 끝점으로 경로가 생성되었는데, 경로 상의 한 점이 출발지가 되면 좀 더 다양한 결과가 나올 것 같아, 그렇게 생성하도록 수정해야할 것 같다.
  
### 경로 길이 문제 해결 방안
두 가지 방식을 고려:

1. **반복 스케일링**: 목표를 5km가 아니라 더 작게(예: 3.5km) 잡아서 스케일한 뒤 경로를 만들고, 나온 경로 길이가 5km에 가까워 질 때까지 목표 거리를 조금씩 올리는 식으로 튜닝
2. **역산 조정**: 한 번 만든 경로 길이를 보고, "실제 경로 ≈ 목표 거리"가 되도록 'target_distance_km'를 역산해서 한번에 조정하는 로직을 넣는 방식

> 경로 길이 피드백을 2회 정도 하는 게 속도면에서 우수할 것 같아서 그 방향으로 코드를 작성하고자 함. (추후에 속도 문제로 두 방식 다 사용하지 않게 됨...)

### 결과 비교

#### 원래 5km로 지정했을 때:

<img width="100%" alt="Image" src="https://github.com/user-attachments/assets/5a866773-10ea-430a-9c26-fae00beed846" />
<img width="100%" alt="Image" src="https://github.com/user-attachments/assets/9d1f384b-e50d-4a64-8688-23727011a3d2" />

#### 경로 피드백 적용 후:

<img width="100%" alt="Image" src="https://github.com/user-attachments/assets/ab604f1d-367a-4acc-bae5-1841ec84116b" />
<img width="100%" alt="Image" src="https://github.com/user-attachments/assets/3e8b4c4a-69c8-46fe-b412-4a7cfd40e65f" />

> 확실히 경로가 5km에 가까워졌다.

## 웨이포인트 방식 테스트

<img width="100%" alt="Image" src="https://github.com/user-attachments/assets/e3afed52-6ad2-463f-b9af-188bd8f2f4c3" />

<img width="100%" alt="Image" src="https://github.com/user-attachments/assets/3a069fb1-b058-41af-aca8-3f8472d25572" />

- 평균 유사도는 웨이포인트보다 비용함수를 적용하는 게 더 오차가 적은 것 같음
- 그러나 top1은 육안으로는 웨이포인트가 더 나은 느낌
- 속도 면에서도 웨이포인트 방식이 50초 정도 빠른 느낌

### 예전 방식 (C3 비용 함수)

- 경로를 찾을 때 비용을 C = α·C1 + β·C2 + γ·C3 한 식으로 썼음.
- 매 단계마다 C3(형태 유사) 가 비용에 들어가서, “그림에 가깝게” 당기면서 경로를 찾음.

### 현재 방식 (웨이포인트)

- 경로를 잇는 비용은 C1, C2만 씀 (A: g는 C2 누적, h는 C1). C3는 경로 탐색 비용에 안 넣음.
- “그림에 가깝게”는 waypoint로 반영: 그림을 샘플링해서 그 점에 가장 가까운 노드를 경유점으로 정하고, 그 경유점들 사이만 A로 연결함.
- C3는 경로를 다 만든 뒤에만 씀: 후보 경로 여러 개 만든 다음 calculate_route_similarity로 유사도 점수만 냄.

> 때문에 속도가 빨라지게 된 것임

## 새로운 문제점 (두 방식 모두에 해당)

<img width="100%" alt="Image" src="https://github.com/user-attachments/assets/18801dbf-54e0-48e6-95d0-64cfddaba3c0" />

유사도가 높게 경로가 생성된 것도 더 가까운 횡단보도가 있음에도 돌아가는 부분이 있다.

<div style="display: flex; gap: 10px">
<img width="100%" alt="Image" src="https://github.com/user-attachments/assets/ad52085e-c84d-4a4c-9dd1-82f531a1571d" />

<img width="100%" alt="Image" src="https://github.com/user-attachments/assets/dcc47d09-f62d-4690-9e5b-1a955053ca31" />
</div>

해당하는 부분의 노드들이 어떻게 분포했는지 찍어보니 확실히 돌아가지 않아도 됨에 불구하고 돌아가고 있는 것을 볼 수 있다.

## 개선 방안 (우선 순위대로 시도 예정)

1. 그림 polyline 진행 방향과 맞는 노드를 우선
2. 그림 선분에 가가운 노드를 고르기
3. 같은 거리대면 "이전 waypoint에서 앞쪽 (진행 방향)에 있는 노드"를 선택


<br />

---

## 1월 31일 - 우회 경로 문제 해결 및 성능 최적화

### 해결해야 할 문제

1. 경로 상 돌아가지 않아도 되는 노드가 충분히 있음에도 불구하고,        
빙 돌아서 경로를 생성하는 현상이 있음 
2. 경로 생성 시 걸리는 속도가 오래 걸림
3. 출발지를 시작과 끝점으로 경로가 생성되는데, 경로 상의 한 점이 되도록 함

### 1차 시도 - 그림 선분에 가까운 노드 구하기

우선은 그림 선분에 가까운 노드를 구하는 로직을 추가해보았다.

<img width="100%" alt="Image" src="https://github.com/user-attachments/assets/3a00918f-b127-4740-884d-d91623d34997" />

<img width="100%" alt="Image" src="https://github.com/user-attachments/assets/0ebf2c29-2ab6-4c7a-8e1c-4a524fee9724" />

확실히 우회하는 부분은 전보다 나아진 듯 하나 **속도가 1037.92초로 너무 걸린다.**

#### 성능 문제 분석

C3 비용함수든 웨이포인트든 어떤 노드가 후보인지 찾는 게 **샘플 수 ✕ 그래프 노드 전체 순회** 를 하는 방식이 문제가 되는 것 같다.

**현재**: "이 점에서 50m 안에 있는 노드"를 찾을 때마다
- 그래프의 노드 전부를 하나씩 보면서
- "이 노드가 50m 안에 있는가?"를 haversine으로 계산 하고 있음

**해결 방향**:
- 전체 노드 순회를 하지 않고도 후보를 찾을 수 있게 방향을 잡아야 할 것 같다.
- 점의 근처 노드만 찾는 함수를 추가하여, 속도 문제를 해결하는 방향으로 가야겠다.

> 즉, "가까운 노드만 골라서 보자"가 목표인데, 매번 전체를 보니까 느려지게 되는 것이다.

### 공간 인덱스(Spatial Index) 도입

**공간 인덱스** 는:
- **한 번** 그래프를 훑으면서
- 각 노드를 **위치 (좌표)** 에 따라 **묶음 (버킷)** 에 넣어두고
- 나중에 "이 좌표 근처 노드 주세요" 라고 하면
- 그 좌표와 가까운 묶음만 열어서 보는 방식이다.

> 즉:       
> - **한 번 쌓아 둔다** = 그래프 로드 후, 또는 waypoint 계산 전에 딱 한 번 "모든 노드를 위치별 묶음으로 정리해 둔다."
> - **한 번 쌓아두면** = 그 다음부터는 "근처 묶음만" 열어서 보면 되니까 매번 전체 5만 개를 볼 필요가 없어짐

#### 그리드 방식 구현

공간 인덱스를 활용하기 위한 가장 단순한 형태가 그리드이기 때문이다

**구조**:
1. 지도를 작은 격자(셀)로 나눔
  - 예: 위도・경도 0.0005도 간격 (대략 50m)으로 나눔
2. 한 번 모든 노드를 순회하면서:
  - "이 노드의 (위도, 경도)가 어느 셀에 속하는가?"를 계산
  - 그 셀의 리스트에 이 노드 ID를 추가
3. 결과:
  - `(셀 행, 셀 열) -> [그 셀 안에 있는 노드 ID들]` 같은 딕셔너리(또는 2차원 배열)가 생김

**사용**:

- "(127.03, 37.50) 근처 50m 노드 필요" 하면
- 그 점이 속한 셀과 그 주변 8 ~ 9개 셀만 열어서
- 그 셀들 안에 있는 노드들만 거리(haversine)를 계산
- **전체 5만 개가 아니라, 보통 수십~수백 개만 보게 된다**

### 결과

#### C3 메트릭 방식

<img width="100%" alt="Image" src="https://github.com/user-attachments/assets/d58a1e74-ddf4-46ea-917d-0b7d97c5b671" />

> C3 메트릭에서는 공간 인덱스 방식이 시작점과 끝점을 가져올 때만 유효하다. 하지만 그럼에도 1037.92초에서 84.68초로 시간이 많이 줄었들었다.

#### 웨이포인트 방식

<img width="100%" alt="Image" src="https://github.com/user-attachments/assets/02cef0aa-c13f-4b15-9f93-118de8ddf132" />

> 1037.92초 → 25.80초로 획기적으로 시간이 줄었다.

### 여전히 남은 우회 경로 문제

<div style="display: flex; gap: 10px">
<img width="100%" alt="Image" src="https://github.com/user-attachments/assets/4b1d6f52-e79f-47cc-b3c0-7d3268a9119a" />
<img width="100%" alt="Image" src="https://github.com/user-attachments/assets/22f94b87-3395-485c-be3b-2a395bd3e0be" />
</div>

#### 원인 분석

처음엔 A* 방식이 문제인가 싶었는데 휴리스틱 방식의 가중치 적용을 빼고 다익스트라만 적용해도 같은 결과가 나왔었다.

<img width="100%" alt="Image" src="https://github.com/user-attachments/assets/e53eff9f-f371-49b1-b2d2-179285e0692c" />

그림을 보면 전에 우회했던 경로를 웨이 포인트 방식으로 하니 노드에 가까운 방향을 선택하여 나아진 부분도 있었다.

그렇지만 여전히 웨이 포인트 방식도 튀는 부분이 있기 때문에 **그림 polyline 진행 방향과 맞는 노드를 우선하는 방향을 시도해 보기로 했음**

그러나 아무 변화가 없었다.

우선은 출발지를 시작과 끝점으로 경로가 생성되었는데, 경로 상의 한 점이 되도록하는 테스트 먼저 해보라는 말이 나와 그것부터 해보려고 한다.









