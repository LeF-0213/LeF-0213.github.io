---
layout: post
related_posts:
    - /frontend/python
title:  "우선 순위 큐"
date:   2025-10-12
categories:
  - frontend
  - python
description: >
  예시를 통해 
---
* toc
{:toc .large-only}

집합 단독으로 출처(x): 최소 신장 트리, 네트워크
# 상호 베타적 집합 알고리즘
* 주로 사용하는 방법으로는 합치기(유니온)와 탐색(파인드)
* 유니온 파인드 알고리즘을 이요하는 순서는 파인드를 먼저 작업하고 그 다음에 유니온(합치기) 순서대로 작업한다.

## 파인드 연산
* 특정 노드의 루트 노드가 무엇인지를 탐색하는 연산
* 특정 노드가 같은 집합에 있는지 확인할 때 사용한다.

예를 들어 A, B 노드가 같은 집합에 속하는지 확인하려면 파인드 연산으로
두 노드의 루트 노드가 같은지 확인한다.

1. 현재 노드의 부모 노드를 확인(부모 노드가 루트 노드이면 찾기 종료)
2. 위의 과정을 통해 찾기 연산이 종료되지 않으면 반복한다.

index(노드의 값) 1 2 3 4 5 6 7
부모 노드        1 1 1 2 1 2 6

찾고자 하는 노드 7의 루트 노드를 찾는다
* 현재 노드와 부모 노드가 같을 때까지 탐색 과정을 반복한다.

다른 예를 보면 find(4) 4 -> 3 -> 2 -> 1
노드의 값 1 2 3 4
부모 노드 1 1 2 3

압축경로 
노드의 값 1 2 3 4
부모 노드 1 1 1 1      

## 합치기 연산
* 두 노드의 루트 노드를 구한다
* 서로 다른 집합이면 하나의 집합으로 합치는 연산을 한다.
* (두 집합의 루트 노드를 같게 한다)

노드의 값 1   2   3   4   5   6   7   8   9
부모 노드 1   2   1   -1  1   -1  2   -1  2

노드의 값 1   2   3   4   5   6   7   8   9
부모 노드 1   1   1   -1  1   -1  2   -1  2

랭크
합치기 연산 비용 문제
트리의 균형을 유지하기 위한 사항

![MaxHeap](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FbPuVM8%2FbtqZ0tCzTir%2FAAAAAAAAAAAAAAAAAAAAAFIQLWJtPoB3-htB63xIj379GLOgBTkEGGAfLOty-WwG%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1761922799%26allow_ip%3D%26allow_referer%3D%26signature%3DEwQVH2QE%252FXswFJhoWFrVKeggx9w%253D)

![MaxHeapImg1](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2Fb2oRsc%2FbtqZZUAq5OE%2FAAAAAAAAAAAAAAAAAAAAACCMkxcdCyO5YnEVdeMMEtSYZOvSxZNki3w_rfjlisRi%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1761922799%26allow_ip%3D%26allow_referer%3D%26signature%3DttSlZ4m6Ulnzf6QVOo7%252BG9%252FSIns%253D)
![MaxHeapImg2](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdna%2FYKTQv%2FbtqZYl6oJFd%2FAAAAAAAAAAAAAAAAAAAAAKfM-3GZRYm0wte6HXHVRlFnibBIa6B97i2zCiW4p-9f%2Fimg.png%3Fcredential%3DyqXZFxpELC7KVnFOS48ylbz2pIh7yKj8%26expires%3D1761922799%26allow_ip%3D%26allow_referer%3D%26signature%3Dm3XcFVYzfCOAR%252BN7jDZwWp5krQI%253D)

우선 순위 큐
우선 순위가 높은 데이터부터 먼저 처리하는 큐이다.
큐는 큐인데 우선순위가 높은 순위에 따라 pop하는 큐
(우선 순위 큐는 데이터의 값이 작을수록 우선 순위가 높다)

우선 순위 동작 원리

1. 빈 우선 순위 큐를 선언(형태는 큐와 동일)
2. 큐에 3 삽입(현재 빈 큐이기 때문에 우선 순위를 생각할 필요(X))
3. 이어서 1 삽입(먼저 들어와 있는 데이터와 비교하여 작으면 교환)
4. pop()을 이용하여 제거

힙으로 우선 순위 큐를 구현 =>
heappush()함수를 사용한다.
이 함수는 heapq 모듈을 가지고 있다.

```python
import heapq

# 빈 힙을 생성
heap = []

# 값을 우선 순위 큐에 삽입(heappush())
heapq.heappush(heap, 10)
heapq.heappush(heap, 5)
heapq.heappush(heap, 20)
heapq.heappush(heap, 1)

# 우선 순위 큐의 상태 출력
print(heap) # [1, 5, 10, 20]

# 우선 순위 큐에서 가장 작은 요소 확인 후 제거(heappop())
print(heapq.heappop(heap)) # 1출력
print(heap) # [5, 10, 20]
```