---
layout: post
related_posts:
    - /frontend/python
title:  "객체지향 프로그래밍(Object-Oriented-Programming, OOP)"
date:   2025-08-05
categories:
  - frontend
  - python
description: >
  
---
* toc
{:toc .large-only}

# 객체지향 프로그래밍(Object-Oriented-Programming, OOP)란?
* 프로그램을 객체(Object)라는 기본 단위로 구성하는 프로그래밍 패러다임이다.
* 객체는 데이터(속성)와 함수(메서드)를 하나의 단위로 묶은 것을 말한다. 
* 클래스라는 틀을 이용해 객체를 정의하고, 이를 통해 여러 개의 객체를 생성할 수 있다. 
* 캡슐화(Encapsulation), 상속(Inheritance), 다형성(Polymorphism) 등의 특징을 활용해 코드를 재사용하고 확장할 수 있다.

## 핵심 개념
* **객체(Object)**:** 데이터(속성)**와** 기능(메서드)**을 하나로 묶은 단위
* **클래스(Class)**: 객체를 만들기 위한 설계도
* **인스턴스(Instance)**: 클래스로부터 생성된 실제 객체

```python
# 클래스 정의(설계도)
class Dog:
    def __init__(self, name, age):
        self.name = name # 속성
        self.age = age

    def bark(self): # 메서드
        return f'{self.name}: 멍멍!'

# 인스턴스 생성 (실제 객체)
dog1 = Dog("솔", 9)
dog2 = Dog("여우", 3)

print(dog1.bark())  # 솔: 멍멍!
print(dog2.bark())  # 여우: 멍멍!
```

## 객체지향 프로그래밍의 장점
* **재사용성**: 한 번 작성한 코드를 여러 곳에서 사용
* **유지보수**: 코드 수정과 버그 추적이 용이
* **확장성**: 기존 코드 수정 없이 기능 추가 가능
* **협업**; 역할 분담이 명확하여 팀 작업에 유리

# OOP의 4대 특징
## 추상화(Abstraction)
* 복잡한 내부 구조를 숨기고 필요한 기능만 제공
* **공통된 특징을 추출하여 일반화**

### ABC(Abstract Base Class)
* **Abstract Base Class**의 약자
* 추상 클래스를 만들기 위한 기본 클래스
* 직접 인스턴스화할 수 없고, 상속받아서만 사용 가능

### abstractmethod
* **추상 메서드**를 정의하는 데코레이터
* 자식 클래스에서 **반드시 구현해야 하는** 메서드 지정
* 구현하지 않으면 에러 발생

### 예제
**추상 클래스**

```python
from abc import ABC, abstractmethod # 추상클래스를 사용하기 위한 모듈 호출

class Animal(ABC):
    @abstractmethod
    def make_sound(self):
        pass

    @abstractmethod
    def move(self):
        pass
```
**구체 클래스**

```python
class Dog(Animal):
    def make_sound(self):
        return "멍멍!"

    def move(self):
        return "네 발로 달립니다"

class Bird(Animal):
    def make_sound(self):
        retrun "짹짹!"

    def move(self):
        return "날아갑니다"
```
**실전 활용**

```python
# 추상 클래스를 직접 인스턴스화할 수 없음
# animal = Animal() # TypeError

# 구체 클래스만 인스턴스화 가능
dog = Dog()
print(dog.make_sound())  # 멍멍!
print(dog.move())        # 네 발로 달립니다

bird = Bird()
print(bird.make_sound()) # 짹짹!
print(bird.move())       # 날아갑니다
```
### 포인트 ⭐️
추상 클래스는 인터페이스 역할을 하며, 모든 하위 클래스가 특정 메서드를 반드시 구현하도록 강제한다.

## 상속(Inheritance)
* 부모 클래스의 속성과 메서드를 자식 클래스가 물려받음
* **코드 재사용을 통한 중복 제거**

### 기본 예제
**부모 클래스**

```python
class Car:
    def __init__(self):
        self.speed = 0
    
    def upSpeed(self, value):
        self.speed += value
        print(f'현재 속도: {self.speed}km/h')

    def downSpeed(self, value):
        self.speed -= value
        if self.speed < 0:
            self.speed = 0
        print(f'현재 속도: {self.speed}km/h')
```
**자식 클래스 1**

```python
class Sedan(Car):
    def upSpeed(self, value):
        self.speed += value
        if self.speed > 150:
            self.speed = 150
        print(f"[세단] 현재 속도: {self.speed}km/h")
```
**자식 클래스 2**

```python
class Truck(Car):
    def upSpeed(self, value):
        self.speed += value
        if self.speed > 100:
            self.speed = 100
        print(f"[트럭] 현재 속도: {self.speed}km/h")
```
**사용 예시**

```python
sedan = Sedan()
sedan.upSpeed(100)  # [세단] 현재 속도: 100km/h
sedan.upSpeed(80)   # [세단] 현재 속도: 150km/h (최대 속도 제한)

truck = Truck()
truck.upSpeed(80)   # [트럭] 현재 속도: 80km/h
truck.upSpeed(50)   # [트럭] 현재 속도: 100km/h (최대 속도 제한)
```
### super() 활용

```python
class Vehicle:
    def __init__(self, brand):
        self.brand = brand
        print(f'{brand} 차량 생성')

class ElectricCar(Vehicle):
    def __init__(self, brand, battery):
        super().__init__(brand)
        self.battery = battery
        print(f'배터리: {battery}kWh')

tesla = ElectricCar("Tesla", 100)
# Tesla 차량 생성
# 배터리: 100kWh
```
### 다중 상속

```python
class Engine:
    def start_engine(self):
        return '엔진 시동'

class GPS:
    def navigate(self, destination):
        return f'{destination}로 안내 시작'

class SmartCar(Car, Engine, GPS):
    pass

smart_car = SmartCar()
smart_car.upSpeed(60)
print(smart_car.start_engine())
print(smart_car.navigate("서울"))
```
## 다형성(Polymorphism)
* 같은 이름의 메서드가 객체에 따라 다르게 동작
* **하나의 인터페이스로 여러 구현**

### 오버로딩(Overloading) vs 오버라이딩(Overriding)

| 구분 | 오버로딩 (Overloading) | 오버라이딩 (Overriding) |
|:------:|----------------------|------------------------|
| **의미** | 같은 이름, 다른 매개변수 | 부모 메서드를 재정의 |
| **위치** | 같은 클래스 내 | 부모-자식 클래스 간 |
| **메서드명** | 동일 | 동일 |
| **매개변수** | 다름 (개수/타입) | 동일 |
| **Python 지원** | ❌ 기본 지원 안 함 | ✅ 지원함 |
| **목적** | 편의성 향상 | 기능 재정의 |
[파이썬 오버로딩 vs 오버라이딩 상세 설명]()

### 메서드 오버라이딩(Overriding)
부모 클래스의 메서드를 자식 클래스에서 재정의

```python
class Animal:
    def speak(self):
        return '동물이 소리를 냅니다.'

class Dog(Animal):
    def speak(self):
        return "멍멍!"

class Cat(Animal):
    def speak(self):
        return "야옹!"

class Sheep(Animal):
    def speak(self):
        return "메에~"
```
**다형성 활용**

```python
animals = [Dog(), Cat(), Cow()]

for animal in animals:
    print(animal.speak())
# 멍멍!
# 야옹!
# 메에~
```
### 연산자 오버로딩(Overloading)
같은 이름의 메서드를, 다른 매개변수로 여러 개 정의

```python
class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __add__(self, other):  # 연산자 오버로딩(+ 연산자를 사용할 때 호출되는 특수 메서드)
        return Vector(self.x + other.x, self.y + other.y)

    def __str__(self):

v1 = Vector(2, 3)
v2 = Vector(5, 7)
v3 = v1 + v2    # __add__ 메서드 호출
print(v3)       # Vector(7, 10)
```

## 캡슐화(Encapsulation)
* 데이터와 메서드를 하나로 묶고 외부 접근을 제어
* **정보 은닉을 통한 데이터 보호**

### 접근 제어자

| 표기 | 의미 | 예시 |
|:------:|------|------|
| `public `| 어디서나 접근 가능 | `self.name` |
| `protected` | 클래스 내부와 자식 클래스에서 접근 | `self._age` |
| `private` | 클래스 내부에서만 접근 | `self.__balance` |

```python
class BankAccount:
    def __init__(self, owner, balance):
        self.owner = owner              # public
        self._accont_num = "123-456"    # protected
        self.__balance = balance        # private

    # Getter
    
```





