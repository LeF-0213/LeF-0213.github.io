---
layout: post
related_posts:
    - /frontend/python
title:  "객체지향 프로그래밍(Object-Oriented-Programming, OOP)"
date:   2025-08-05
categories:
  - frontend
  - python
description: >
  
---
* toc
{:toc .large-only}

# 객체지향 프로그래밍(Object-Oriented-Programming, OOP)란?
* 프로그램을 객체(Object)라는 기본 단위로 구성하는 프로그래밍 패러다임이다.
* 객체는 데이터(속성)와 함수(메서드)를 하나의 단위로 묶은 것을 말한다. 
* 클래스라는 틀을 이용해 객체를 정의하고, 이를 통해 여러 개의 객체를 생성할 수 있다. 
* 캡슐화(Encapsulation), 상속(Inheritance), 다형성(Polymorphism) 등의 특징을 활용해 코드를 재사용하고 확장할 수 있다.

## 핵심 개념
* **객체(Object)**:** 데이터(속성)**와** 기능(메서드)**을 하나로 묶은 단위
* **클래스(Class)**: 객체를 만들기 위한 설계도
* **인스턴스(Instance)**: 클래스로부터 생성된 실제 객체

```python
# 클래스 정의(설계도)
class Dog:
    def __init__(self, name, age):
        self.name = name # 속성
        self.age = age

    def bark(self): # 메서드
        return f'{self.name}: 멍멍!'

# 인스턴스 생성 (실제 객체)
dog1 = Dog("솔", 9)
dog2 = Dog("여우", 3)

print(dog1.bark())  # 솔: 멍멍!
print(dog2.bark())  # 여우: 멍멍!
```

## 객체지향 프로그래밍의 장점
* **재사용성**: 한 번 작성한 코드를 여러 곳에서 사용
* **유지보수**: 코드 수정과 버그 추적이 용이
* **확장성**: 기존 코드 수정 없이 기능 추가 가능
* **협업**; 역할 분담이 명확하여 팀 작업에 유리

## 객체(Object)란?
* **속성(Attribute)**과 **메서드(Method)**를 가진 독립적인 단위
* 현실 세계의 사물이나 개념을 프로그램으로 표현한 것
* 클래스를 통해 생성된 실체를 **인스언스(Instance)**라고 함

# OOP의 4대 특징

| 특징 | 설명 | 키워드 |
|------|------|--------|
| **추상화** | 복잡한 것을 단순화, 핵심만 표현 | `ABC`, `@abstractmethod` |
| **상속** | 부모 클래스의 기능을 자식이 물려받음 | `class Child(Parent)`, `super()` |
| **다형성** | 같은 메서드가 다르게 동작 | 오버라이딩, 덕 타이핑 |
| **캡슐화** | 데이터 은닉 및 보호 | `__private`, `@property` |

## 추상화(Abstraction)
* 복잡한 내부 구조를 숨기고 **필요한 기능만 외부에 제공**
* **공통된 특징을 추출하여 일반화**하는 과정
* 불필요한 세부사항은 감추고 핵심적인 개념만 표현

### 추상화의 장점
* 코드의 복잡도 감소
* 인터페이스와 구현의 분리
* 유지보수성 향상

### ABC(Abstract Base Class)
* **Abstract Base Class**의 약자
* 추상 클래스를 만들기 위한 기본 클래스
* 직접 인스턴스화할 수 없고, 상속받아서만 사용 가능

### abstractmethod
* **추상 메서드**를 정의하는 데코레이터
* 자식 클래스에서 **반드시 구현해야 하는** 오버라이딩 메서드 지정
* 구현하지 않으면 에러 발생

### ❌ 에러 예제
```python
from abc import ABC, abstractmethod

class Animal(ABC):
  @abstractmethod
  def speak(self):
    pass
  
class Dog(Animal):
  pass

sol = Dog()     # TypeError: Can't instantiate abstract class Dog without an implementation for abstract method 'speak'
```

### ✅ 맞는 예제
```python
from abc import ABC, abstractmethod

class Animal(ABC):
  @abstractmethod
  def speak(self):
    pass
  
class Dog(Animal):
  def speak(self):
    print('멍멍')

sol = Dog()
sol.speak()     # 멍멍
```

### 예제

```python
# 추상 클래스 (설계도의 설계도)
from abc import ABC, abstractmethod # 추상클래스를 사용하기 위한 모듈 호출

class Animal(ABC):
    @abstractmethod
    def make_sound(self):
        pass

    @abstractmethod
    def move(self):
        pass

# 구체 클래스
class Dog(Animal):
    def make_sound(self):
        return "멍멍!"

    def move(self):
        return "네 발로 달립니다"

class Bird(Animal):
    def make_sound(self):
        retrun "짹짹!"

    def move(self):
        return "날아갑니다"

# 사용

# 추상 클래스를 직접 인스턴스화할 수 없음
# animal = Animal() # TypeError

# 구체 클래스만 인스턴스화 가능
dog = Dog()
print(dog.make_sound())  # 멍멍!
print(dog.move())        # 네 발로 달립니다

bird = Bird()
print(bird.make_sound()) # 짹짹!
print(bird.move())       # 날아갑니다
```
### 포인트 ⭐️
추상 클래스는 인터페이스 역할을 하며, 모든 하위 클래스가 특정 메서드를 반드시 구현하도록 강제한다.

## 상속(Inheritance)
* 기존 클래스의 **속성과 메서드를 물려받아** 새로운 클래스를 만드는 것
* 즉, 부모 클래스(상위 크래스, Super class)의 속성과 메서드를 자식 클래스(하위 클래스, Sub calss)가 물려받아 기능을 수정하거나 추가할 수 있는 기능을 제공한다.
* **코드 재사용을 통한 중복 제거** 및 확장성을 높임
* 파이썬의 모든 클래스는 `object`라는 클래스로부터 상속받는다.

```python
class Parent:
    pass

class Child(Parent):
    pass
```

### 클래스 상속 시 생성자 호출 순서
1. 자식 클래스(child class)의 생성자가 호출된다.
2. 자식 클래스의 생성자에서 부모 클래스(parent class)의 생성자를 호출해야 한다. 이를 위해 super() 함수를 사용한다. super() 함수는 현재 클래스의 부모 클래스를 참조하며, 부모 클래스의 생성자를 호출할 수 있다.
3. 부모 클래스의 생성자가 호출된다.
4. 부모 클래스의 생성자가 실행을 마치면 자식 클래스의 생성자로 돌아가 자식 클래스의 생성자 코드가 실행된다.

```python
class Parent:
    def __init__(self):
        print('부모 클래스 생성자 호출')

class Child(Parent):
    def __init__(self):
        print('Child 클래스 생성자 호출')
        super().__init__()
        print('모든 생성자 호출 완료')

child = Child()
"""
Child 클래스 생성자 호출
부모 클래스 생성자 호출
모든 생성자 호출 완료
"""
```

### Object 클래스
* Object 클래스는 파이썬에서 모든 클래스의 부모 클래스 역할을 하는 기본 클래스이다. 
* 파이썬에서 정의하는 모든 클래스는 자동으로 Object 클래스를 상속받는다. 
* 이를 통해 파이썬의 모든 객체는 Object 클래스에서 제공하는 기본적인 동작과 메서드를 사용할 수 있게 된다. 
* 예를들어 \_\_str\_\_(), \_\_repr\_\_(), \_\_eq\_\_(), \_\_hash\_\_() 등이 있다.

```python
class MyClass:
    pass

# 위의 코드는 다음과 동일합니다.
class MyClass(object):
    pass
```

### 기본 예제

```python
# 부모 클래스(기본 자동차)
class Car:
    def __init__(self):
        self.speed = 0
    
    def upSpeed(self, value):
        self.speed += value
        print(f'현재 속도: {self.speed}km/h')

    def downSpeed(self, value):
        self.speed -= value
        if self.speed < 0:
            self.speed = 0
        print(f'현재 속도: {self.speed}km/h')

# 자식 클래스 1
class Sedan(Car):
    def upSpeed(self, value):
        self.speed += value
        if self.speed > 150:
            self.speed = 150
        print(f"[세단] 현재 속도: {self.speed}km/h")

# 자식 클래스 2
class Truck(Car):
    def upSpeed(self, value):
        self.speed += value
        if self.speed > 100:
            self.speed = 100
        print(f"[트럭] 현재 속도: {self.speed}km/h")

# 사용 예시
sedan = Sedan()
sedan.upSpeed(100)      # [세단] 현재 속도: 100km/h
sedan.upSpeed(80)       # [세단] 현재 속도: 150km/h (최대 속도 제한)
sedan.downSpeed(50)     # 현재 속도: 100km/h

truck = Truck()
truck.upSpeed(80)       # [트럭] 현재 속도: 80km/h
truck.upSpeed(50)       # [트럭] 현재 속도: 100km/h (최대 속도 제한)
truck.downSpeed(100)    # 현재 속도: 0km/h
```
### super() 함수
* `super()`는 파이썬의 내장 함수로서, 상속과 관련된 작업을 수행할 때 사용된다. 
* 특히, 자식 클래스에서 부모 클래스의 메서드를 호출할 때 사용된다. 
* `super()`의 주요 목적은 자식 클래스에서 부모 클래스의 메서드를 **오버라이드(재정의)**하면서도, 
* 그 오버라이드된 메서드 내에서 **부모 클래스의 원본 메서드**를 호출하는 것이다.

```python
class Vehicle:
    def __init__(self, brand):
        self.brand = brand
        print(f'{brand} 차량 생성')

class ElectricCar(Vehicle):
    def __init__(self, brand, battery):
        super().__init__(brand)
        self.battery = battery
        print(f'배터리: {battery}kWh')

tesla = ElectricCar("Tesla", 100)
# Tesla 차량 생성
# 배터리: 100kWh
```

### MRO
* MRO(Method Resolution Order)는 파이썬에서 **다중 상속 시 메서드나 속성을 찾는 순서**를 정의하는 규칙이다. 
* MRO는 특히 여러 부모 클래스를 상속받는 경우에 어떤 부모 클래스에서 메서드를 먼저 찾을지를 결정하며, 
* 이를 통해 클래스 간의 메서드 충돌을 해결할 수 있다.

```python
class Base:
    def hello(self):
        print('Base의 hello()')             # 7
        print('Base 클래스의 hello() 메서드')   # 8

class A(Base):
    def hello(self):
        print('A의 hello()')               # 3
        super().hello()                   # 4
        print('A 클래스의 hello() 메서드')    # 10

class B(Base):
    def hello(self):
        print('B의 hello()')               # 5
        super().hello()                   # 6
        print('B 클래스의 hello() 메서드')    # 9

class Child(A, B):
    def hello(self):
        print('Child의 hello()')             # 1
        super().hello()                     # 2
        print('Child 클래스의 hello() 메서드')  # 11

child = Child()
child.hello()
"""
Child의 hello()
A의 hello()
B의 hello()
Base의 hello()
Base 클래스의 hello() 메서드
B 클래스의 hello() 메서드
A 클래스의 hello() 메서드
Child 클래스의 hello() 메서드
"""

Child.mro()
# [__main__.Child, __main__.A, __main__.B, __main__.Base, object]
```
### 다중 상속
* 다중 상속은 클래스가 **둘 이상의 부모 클래스로부터 상속을 받는 기능**을 의미한다. 
* 파이썬은 다른 많은 객체 지향 언어(ex. 자바)와 달리 다중 상속을 지원한다. 
* 다중 상속을 사용하면 **코드의 재사용성**을 향상시킬 수 있지만, 
* 동시에 **복잡성이 높아지기 때문에 주의**해야 한다.

```python
class Vehicle:
    def __init__(self):
        self.speed = 0
        print("Vehicle 초기화")

    def move(self):
        return "이동 중"

class Engine:
    def __init__(self):
        print("Engine 초기화")

    def start_engine(self):
        return '엔진 시동'

    def move(self):        
        return "엔진으로 이동"

class GPS:
    def __init__(self):
        print("GPS 초기화")

    def navigate(self, destination):
        return f'{destination}로 안내 시작'

    def move(self):       

class SmartCar(Vehicle, Engine, GPS):
    def __init__(self):
        super().__init__()
        print("SmartCar 초기화 완료")

    def upSpeed(self, value):
        self.speed += value
        print(f'현재 속도: {self.speed}km/h')

smart_car = SmartCar()
# Vehicle 초기화
# SmartCar 초기화 완료
print(SmartCar.__mro__)
# (<class '__main__.SmartCar'>, <class '__main__.Vehicle'>, <class '__main__.Engine'>, <class '__main__.GPS'>, <class 'object'>)
smart_car.upSpeed(60)              # 현재 속도: 60km/h
print(smart_car.start_engine())    # 엔진 시동
print(smart_car.navigate("서울"))   # 서울로 안내 시작   
print(smart_car.move())            # 이동 중
```

## 다형성(Polymorphism)
* 같은 이름의 메서드가 **객체에 따라 다르게 동작**
* **하나의 인터페이스로 여러 구현**

### 오버로딩(Overloading) vs 오버라이딩(Overriding)
* **메서드 오버라이딩**: 자식 클래스에서 부모 클래스의 메서드를 재정의
* **메서드 오버로딩**: Python은 기본적으로 지원하지 않음(기본 값이나 가변인자로 구현)

| 구분 | 오버로딩 (Overloading) | 오버라이딩 (Overriding) |
|:------:|----------------------|------------------------|
| **의미** | 같은 이름, 다른 매개변수 | 부모 메서드를 재정의 |
| **위치** | 같은 클래스 내 | 부모-자식 클래스 간 |
| **메서드명** | 동일 | 동일 |
| **매개변수** | 다름 (개수/타입) | 동일 |
| **Python 지원** | ❌ 기본 지원 안 함 | ✅ 지원함 |
| **목적** | 편의성 향상 | 기능 재정의 |

[파이썬 오버로딩 vs 오버라이딩 상세 설명]()

### 메서드 오버라이딩(Overriding)
* **부모 클래스의 메서드를 자식 클래스에서 재정의**
* 메서드 오버라이딩(Method Overriding)은 객체 지향 프로그래밍에서 중요한 개념 중 하나로, 
* 서브 클래스(자식 클래스)에서 슈퍼 클래스(부모 클래스)의 메서드를 재정의하는 것을 의미한다. 
* 오버라이딩을 사용하면, 서브 클래스에서 상속받은 메서드의 동작을 변경하거나 확장할 수 있다. 
* 오버라이딩할 때, **메서드의 이름은 물론이고 매개변수의 타입과 개수도 일치해야 한다.**
* 반환 타입은 일치할 필요는 없지만, 일반적으로 같게 유지하는 것이 좋다.

```python
class Animal:
    def speak(self):
        return '동물이 소리를 냅니다.'

class Dog(Animal):
    def speak(self):    # 메서드 오버라이딩
        return "멍멍!"

class Cat(Animal):
    def speak(self):
        return "야옹!"

class Sheep(Animal):
    def speak(self):
        return "메에~"

# 다형성 활용
animals = [Dog(), Cat(), Cow()]

for animal in animals:
    print(animal.speak()) # 같은 메서드지만 다른 결과
# 멍멍!
# 야옹!
# 메에~
```
### 연산자 오버로딩(Overloading)
같은 이름의 메서드를, 다른 매개변수로 여러 개 정의

```python
class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __add__(self, other):  # 연산자 오버로딩(+ 연산자를 사용할 때 호출되는 특수 메서드)
        return Vector(self.x + other.x, self.y + other.y)

    def __str__(self):

v1 = Vector(2, 3)
v2 = Vector(5, 7)
v3 = v1 + v2    # __add__ 메서드 호출
print(v3)       # Vector(7, 10)
```

## 캡슐화(Encapsulation)
* 데이터와 메서드를 하나로 묶고 **외부에서 직접 접근을 제한(인터페이스만 열어둠)**
* 데이터 **은닉(Information Hiding)**을 통해 객체의 무결성 보호
* **접근 제어자**: public, protected, private

### 캡슐화의 장점
* 데이터 보호 및 무결성 유지
* 내부 구현 변경 시 외부 코드에 영향 최소화
* 코드의 복잡도 감소

### 접근 제어자

| 표기 | 의미 | 예시 |
|:------:|------|------|
| `public `| 어디서나 접근 가능 | `self.name` |
| `protected` | 클래스 내부와 자식 클래스에서 접근 | `self._age` |
| `private` | 클래스 내부에서만 접근 | `self.__balance` |

#### 기본 예제

```python
class Animal:
  def __init__(self, name, age):
    self.name = name
    self.__age = age # __로 시작하면 private 속성
  def get_age(self):
    return self.__age
  def set_age(self, age):
    if age > 0:
      self.__age = age
    else:
      print('나이는 양수여야 합니다.')

class Dog(Animal):
  def __init__(self, name, age, breed):
    super().__init__(name, age)
    self.breed = breed
  def bark(self):
    print(f'{self.name}가 멍멍 짓습니다.')

# 사용
dog = Dog('솔', 5, '말티푸')
dog.bark()

print(dog.name)
# print(dog.age) # AttributeError: 'Dog' object has no attribute 'age'
#print(dog.__age) # AttributeError: 'Dog' object has no attribute '__age'
print(dog.get_age())       # 5
dog._age = 10             
print(dog._age)            # 10
print(dog.get_age())       # 5, 실제 dog 객체에서는 변경되지 않음
print.set_age(9)           
print(dog.get_age())       # 9
```
### 접근 제어자 예제

```python
class BankAccount:
    def __init__(self, owner, balance):
        self.owner = owner              # public (공개)
        self._accont_num = "123-456"    # protected (보호)
        self.__balance = balance        # private (비공개)

    # Getter
    def get_balance(self):
        return self.__balance

    # Setter 메서드
    def deposit(self, amount):
        if amount > 0:
            self.__blance += amount
            print(f'{amount}원 입금 완료')
        else:
            print('입금액은 0보다 커야 합니다.')

    def withdraw(self, amount):
        if 0 < amount <= self.__balance:
            self.__balance -= amount
            print(f'{amount}원 출금 완료')
        else:
            print('잔액이 부족하거나 잘못된 금액입니다')

# 사용 예시
account = BankAccount("김사과", 10000)

# public 접근
print(account.owner)    # 김사과

# protected 접근 (가능하지만 권장하지 않음)
print(account._account_number)  # 123

# private 접근 (불가능)
# print(account.balance)    # AttributeError: 'account' object has no attribute 'balance'
# print(account.__balance)  # AttributeError: 'account' object has no attribute '__balance'

# Getter/Setter를 통한 접근
print(account.get_balance())    # 10000
account.deposit(5000)           # 5000원 입근 완료
account.withdraw(3000)          # 3000원 출금 완료
print(account.get_balance())    # 12000
```
### 프로퍼티(Property) 사용

```python
class Person:
    def __init__(self, name, age):
        self._name = name
        self._age = age

    @Property
    def age(self):
        # Getter
        return self._age

    @age.setter
    def age(self, value)
        # Setter
        if value < 0:
            raise valueError("나이는 0보다 작을 수 없습니다")
        self._age = value

    @age.deleter
    def age(self):
        # Deleter
        print('나이 정보 삭제')
        def self._age

# 사용
person = Person('김사과', 20)

# Getter(메서드 처럼 ()를 쓰지 않음)
print(person.age)   # 20

# Setter (= 연산자 사용)
person.age = 21
print(person.age)   # 21

# 잘못된 값 설정 시도
try:
    person.age = -5 # ValueError
except ValueError as e:
    print(e)        # 나이는 0보다 작을 수 없습니다

# Deleter
del person.age      # 나이 정보 삭제 
```

### 캡슐화와 추상화 예제 - 은행 계좌 시스템
```python
from abc import ABC, abstractmethod
from datetime import datetime

# 추상화
# 추상클래스로 '계좌'의 공통 인터페이스 정의
class Account(ABC):
    # 추상화: 구체적인 구현은 숨기고, 필수 기능만 정의
    # 모든 계좌가 가져야 할 '입금', '출금', '잔액조회' 기능을 선언

    @abstractmethod
    def deposit(self, amount):
        pass

    @abstractmethod
    def withdraw(self, amount):
        pass

    @abstractmethod
    def get_balance(self):
        pass

# 캡슐화
# 데이터(잔액)을 private으로 숨기고, 메서드를 통해서만 접근 가능
class SavingsAccount(Account):
    # 캡슐화: 내부 데이터(__balance)를 외부에서 직접 접근 못하게 숨김
    # 정해진 메서드를 통해서만 안전하게 데이터 조작 가능

    def __init__(self, owner, initial_balance=0):
        self.__owner = owner
        self.__balance = initial_balance
        self.__transaction_history = []
        self.__interest_rate = 0.02

    def deposit(self, amount):
        # 입금 메서드 - 유효성 검사 후 안전하게 잔액 증가
        if amount <= 0:
            raise ValueError("입금액은 0보다 커야 한다.")

        self.__balance += amount
        self.__add_transaction("입금", amount)
        print(f'{amount:,}원 입금 완료. 현재 잔액: {self.__balance:,}원')

    def withdraw(self, amount):
        # 출금 메서드 - 잔액 검증 후 안전하게 출금
        if amount <= 0:
            raise ValueError('입금액은 0보다 커야 합니다.')

        if amount > self.__balance:
            raise ValueError(f'잔액 부족! 현재 잔액: {self.__balance:,}원')

        self.__balance -= amount
        self.__add_transaction("출금", amount)
        print(f'{amount:,}원 입금 완료. 현재 잔액: {self.__balance:,}원')

    def get_balance(self):
        # 잔액 조회 - 읽기 전용으로 안젠하게 제공
        return self.__balance

    def apply_interest(self):
        # 이자 적용 - 내부 로직을 캡슐화
        interest = self.__balance * self.__interest_rate
        self.__balance += interest
        self.__add_transaction("이자", interest)
        print(f'이자 {interest:,.0f}원 적용됨')

    def __add_transaction(self, type, amount):
        # private 메서드 - 같은 클래스 안에서만 사용(내부적으로만 사용 가능)
        # 외부에서는 호출할 수 없음

        self.__transaction_history.append({
            'type': type,
            'amount': amount,
            'time': datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        })

    def show_history(self):
        # 거래 내역 조회
        print(f'\n[{self.__owner}님의 거래 내역]')
        for trans in self.__transaction_history:
            print(f"{trans['time']} | {trans['type']}: {trans['amount']:,}원")

class CheckingAccount(Account):
    # 당좌예금 계좌 - 마이너스 한도 기능 추가

    def __init__(self, owner, initial_balance=0, overdraft_limit=1000000):
        self.__owner = owner
        self.__balance = initial_balance
        self.__overdraft_limit = overdraft_limit    # 마이너스 한도

    def deposit(self, amount):
        if amount <= 0:
            raise ValueError('출금액은 0보다 커야 합니다.')
        self.__balance += amount
        print(f'{amount:,}원 입금 완료. 현재 잔액: {self.__balance:,}원')

    # 마이너스 한도까지 출금 가능
    def withdraw(self, amount):
        if amount <= 0:
            raise ValueError("출금액은 0보다 커야 합니다.")

        available = self.__balance + self.__overdraft_limit
        if amount > available:
            raise ValueError(f'출금 한도 초과! (가능 금액: {available:,}원')

        self.__balance -= amount
        print(f'{amount:,}원 출금 완료. 현재 잔액: {self.__balance:,}원')

    def get_balance(self):
        return self.__balance 

# 사용 예시
if __name__ == '__main__':
    print("은행 계좌 시스템 test 시작")
    print("=" * 50)

    # 적금 계좌 생성
    savings = SavingsAccount("솔", 1000000)

    print("적금 계좌 테스트")
    savings.deposit(500000)
    savings.withdraw(200000)
    savings.apply_interest()

    # 캡슐화 확인(직접 접근 시도: 에러 발생)
    print(f'현재 잔액: {savings.get_balance():,}원')

    savings.show_history()

    # 당좌 계좌 생성
    print("[고영희 당좌 계좌 생성]")
    checking = CheckingAccount("고영희", 500000, overdraft_limit=2000000)
    checking.deposit(300000)
    checking.withdraw(1000000)
    print(f"현재 잔액: {checking.get_balance():,}원")

    # 추상화의 이점: 다형성
    print("추상화의 이점: 다형성")
    accounts = [savings, checking]

    for account in accounts:
        print(f"계좌 잔액: {account.get_balance():,}원")

# 결과
은행 계좌 시스템 test 시작
==================================================
적금 계좌 테스트
500,000원 입금 완료. 현재 잔액: 1,500,000원
200,000원 입금 완료. 현재 잔액: 1,300,000원
이자 26,000원 적용됨
현재 잔액: 1,326,000.0원

[솔님의 거래 내역]
2025-10-28 08:46:05 | 입금: 500,000원
2025-10-28 08:46:05 | 출금: 200,000원
2025-10-28 08:46:05 | 이자: 26,000.0원
[고영희 당좌 계좌 생성]
300,000원 입금 완료. 현재 잔액: 800,000원
1,000,000원 출금 완료. 현재 잔액: -200,000원
현재 잔액: -200,000원
추상화의 이점: 다형성
계좌 잔액: 1,326,000.0원
계좌 잔액: -200,000원
```





