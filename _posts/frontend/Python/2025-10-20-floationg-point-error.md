---
layout: post
related_posts:
    - /frontend/python
title:  "부동소수점 오차(Floating-point Error)와 실수의 메모리 표현"
date:   2025-10-20
categories:
  - frontend
  - python
description: >
  고정소수점 방식과 부동소수점 방식의 차이를 통해 부동소수점 오차를 이해 및 해결방안 정리
---
* toc
{:toc .large-only}

# 실수의 메모리 표현
컴퓨터 2진수 체계를 데이터를 저장하며, 실수를 표현하는 방식으로는 크게 **고정소수점**과 **부동소수점**으로 나눌 수 있다.
## 고정소수점 방식(Fixed-Point)
### 핵심 특징
* **소수점 위치가 고정**되어 있다.
* **정수와 소수부의 자릿수를 미리 고정**하여 표현

### 예시 (32비트 시스템)
![FixedPoint](https://resources-public-blog.modulabs.co.kr/blog/prd/content/259164/fixed-points.png)
`253.3`을 표현할 때,
* **부호**: 1비트 (`0` = 양수, `1` = 음수)
* **정수**: 16비트 -> `0000000100000111`(263)
* **소수**: 15비트 -> `010011001100110`(0.3, 고정소수점 방식에서는 정확한 표현은 불가능하므로 근사치를 사용)

### 장단점
* **장점**:
  * 구현이 쉽고 계산 속도가 빠르며 정확도가 일정함
* **단점**:
  * **표현 점위가 좁음**: 16비트로 정수부를 표현하면 최대 `약 65,635`까지만 가능
  * **공간 낭비 발생**: 정수부가 작으면 정수 비트가 낭비되고, 소수부가 작으면 소수 비트가 낭비됨

## 부동소수점 방식(Floating-Point)
### 핵심 특징
* **소수점 위치가 변동**된다
* 소수점 위치를 나타내는 **지수부(exponent)**와 유효 숫자를 나타내는 **가수부(mantissa)**로 나누어 표현
* 표현 형식: `1.xxx × 2^n`

### IEEE 754 표준(32비트)
**IEEE 754**는 **컴퓨터에서 부동소수점 연산을 수행하는 표준 규격**이다
* **부호**: 1비트
* **지수부**: 8비트 (소수점 위치를 나타내는 제곱승)
* **가수부**: 23비트 (실제 실수 데이터 비트)

## 실제 변환 예시: 263.3을 IEEE 754로 표현
### 단계 1: 2진수 변환
* 263(정수부) = `100000111`
* 0.3(소수부) = `01001100110011001100110011...`(무한반복)
* 전체: `100000111.01001100110011001100110011...`

### 단계 2: 정규화
* `1.0000011101001100110011001100110011... × 2^8`
* 소수점을 왼쪽으로 이동시켜 맨 앞자리가 1이 되도록 함

### 단계 3: 각 부분 계산
1. 부호(Sign) - 1비트
   * 양수이므로 `0`
2. 지수(Expopnent) - 8비트
   * 실제 지수: 8이지만 IEE 754에서는 **Bias(127)를 더함**
   * 저장 값: `8 + 127 = 135`
   * 2진수: `10000111`
3. 가수(MAntissa) - 23비트
   * 정규화된 형태에서 **소수점 이하 부분만** 저장 (맨 앞 1은 암묵적으로 생략)
   * `0000011101001100110011001100110011...`에서 23비트만 추출
   * 최종: `00000111010011001100110`

### 단계 4: 최종 IEEE 754 표현 (32비트)
![FloatingPoint](https://resources-public-blog.modulabs.co.kr/blog/prd/content/259164/floating-point.png)
### 장단점
* **장점**:
   * **매우 크거나 작은 수를 효율적**으로 표현 가능
   * 가수부 23비트를 모두 실수 표현에 사용하므로 **더 넓은 범위** 표현
   * 정수부/소수부 구분 없이 가수부 내에서 전체 실수를 표현하므로 **공간 낭비 없음**
* **단점**:
   * 계산 시 **오차 발생 가능** (근사값 표현)
   * 0.3과 같은 소수는 2진수로 무한반복되므로 23비트로 잘라내면서 **정밀도 손실 발생**

# 부동소수점 오차가 발생하는 이유
## 근본 원인: 진법 변환의 한계
**10진법에서는 정확한 소수가 2진법에서는 무한소수가 됨**
=> 이 과정에서 **정밀도 손실**이 발생

## 어떤 소수가 정확하게 표현 가능할까?
2진법으로 **유한소수**로 표현되는 값들만 정확하다

### 2진법 소수 자릿값 표
| 2진법 | 자릿값 | 10진법 | 분수 |
|:------:|:--------:|:--------:|:------:|
| 0.1₂ | 1×(1/2) | 0.5 | 1/2 |
| 0.01₂ | 1×(1/4) | 0.25 | 1/4 |
| 0.001₂ | 1×(1/8) | 0.125 | 1/8 |
| 0.0001₂ | 1×(1/16) | 0.0625 | 1/16 |
| 0.11₂ | 1×(1/2) + 1×(1/4) | 0.75 | 3/4 |
| 0.101₂ | 1×(1/2) + 1×(1/8) | 0.625 | 5/8 |

### 정확하게 표현 가능한 소수
 * `0.5` = `0.1₂` = `1/2`
 * `0.25` = `0.01₂` = `1/4`
 * `0.125` = `0.001₂` = `1/8`
 * `0.75` = `0.11₂` = `3/4`

### 정확하게 표현 불가능한 소수
 * `0.1` = 1/10 (무한반복)
 * `0.2` = 2/10 (무한반복)
 * `0.3` = 3/10 (무한반복)
 * `0.7` = 7/10 (무한반복)
  
## 부동소수점 오차의 종류
### 표현 오차(Representation Error)
 * 원인: `10진 소수`를 `2진법`으로 변환할 때 무한소수가 됨
 * 예: `0.1`을 정확히 표현할 수 없음

### 반올림 오차(Rounding Error)
 * 원인: 23비트(또는 52비트)로 절단하면서 발생
 * 예: `0.00011001100110011001100110011...`을 `23비트`에서 자름

### 누적 오차(Accumulated Error)
 * 원인: 여러 번의 연산을 거치면서 작은 오차가 누적됨
 * 예: 반복문에서 `0.1`을 계속 더하는 경우
```python
sum = 0.0
for i in range(10):
  sum += 0.1
print(sum) # 0.9999999999999999 (예상: 1.0)
```

## 부동소수점 오차 해결 방법
### Decimal 모듈 사용(정확한 10진 연산)
```python
from decimal import Decimal
# Decimal 연산
print(Decimal('0.1') + Decimal('0.2')) # 0.3
```
### 정수 연산으로 변환
```python
price_cents = 10 + 20 # 정수 연산
price = price_cents / 100 # 0.3
```
### 비교 시 epsilon 사용
```python
epsilon = 1e-10
if abs((0.1 + 0.2) - 0.3) < epsilon: # True
  print("같다")
```
### math.isclose() 메소드 사용
```python
import math

print(math.isclose(0.1 + 0.2, 0.3)) # True
```

## 핵심 정리
### 부동소수점 오차가 발생하는 3가지 핵심 이유
 * **진법 불일치**: 10진 소수 → 2진 소수 변환 시 무한소수가 됨
 * **비트 제한**: 무한소수를 유한한 비트(23비트 또는 52비트)에 저장
 * **절단/반올림**: 저장 가능한 범위를 초과하는 부분을 잘라냄

### 기억해야 할 것
 * 부동소수점은 **근사값**이다.
 * `==` 비교는 위험하다.
 * 금융 계산에는 `Decimal` 사용을 권장한다.
 * **2의 거듭제곱** 분수(0.5, 0.25 등)는 정확하다.