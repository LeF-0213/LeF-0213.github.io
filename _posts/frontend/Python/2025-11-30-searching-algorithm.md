---
layout: post
related_posts:
    - /frontend/python
title:  "[Python] 탐색 알고리즘[Searching Algorithm]"
date:   2025-11-19
categories:
  - frontend
  - python
description: >
  
---
* toc
{:toc .large-only}

## 목차

1. [그래프 표현 방법](그래프-표현-방법)
2. [선형 탐색 (Linear Search)](선형-탐색-(Linear-Search))
3. [이진 탐색 (Binary Search)](이진-탐색-(Binary-Search))
4. [DFS (깊이 우선 탐색)](DFS-(깊이-우선-탐색))
5. [BFS (너비 우선 탐색)](BFS-(너비-우선-탐색))
6. [Union-Find (상호소 집합)](Union-Find-(상호소-집합))

## 그래프 표현 방법
### 그래프의 기본 용어
* **노드(Vertex)**: 그래프의 정점
* **간선(Edge)**: 노드와 노드를 연결하는 선
* **가중치(Weight)**: 간선에 부여된 값

### 인접 행렬 (Adjacency Matrix)

> **정의**      
> 2차원 배열로 그래프의 연결 관계를 표현하는 방식이다.      
> **특징**      
> * `graph[i][j]`가 1이면 노드 i와 j가 연결됭어 있음.
> * 연결되지 않은 노드끼리는 무한의 비용(INF = 999999999) 또는 0
> * 가중치가 있는 경우 해당 

완전 탐색
DFS(stack) 깊이 우선 탐색
BFS(queue) 너비 우선 탐색
재귀 함수
↓
탐색 알고리즘
1. 인접 행렬
2차원 배열로 연결관계를 표현 
1. 인접 리스트
리스트로 연결 관계를 표현
=> 트리 그래프

노드(vertex)
간선
가중치

### 인접 행렬 
* 2차원 배열에 각 노드가 연결된 형태를 기록
* 파이썬에서는 2차원 리스트
* 연결 되지 않는 노드끼리는 무한의 비용(INF = 999999999)

   0  1  2
0  0  5  2
1  5  0 INF
2  2 INF 0
파이썬의 2차원 리스트 인접 행렬
```python
graph = [
    [0, 5, 2],
    [5, 0, INF],
    [2, INF, 0]
  ]
```

## DFS
stack 자료 구조를 이용하여 구체적인 동작을 한다.
1. 탐색 시작노드를 스택에 삽입하고 방문 처리한다.(노드에 다시 삽입되지 않게 하기 위해)
2. 스택의 최상단 노드에 방문하지 않은 인접 노드가 있으면, 그 인접 노드를 스택에 넣고 방문 처리 한다. (stack 방식이 적용)
3. 2번 과정을 더 이상 수행할 수 없을 때까지 반복한다.(단말노드를 만날 때까지)

코딩테스트에서는 번호가 낮은 순서부터 처리한다.

먼저 공백 스택을 생성

1. 시작 노드 1을 스택에 삽입하고, 방문 처리를 한다.
2. 스택의 최상단 노드 1을 기준으로 인접한 노드를 찾는다. (2, 3, 8 노드) 이 중에서 가장 작은 노드를 스택에 삽입하고 방문 처리
3. 스택의 최상단 노드 2을 기준으로 방문하지 않은 인접한 노드를 찾는다. (7, 8 노드) 그 중 가장 작은 노드의 값을 스택에 삽입 후 방문 처리 
4. 스택의 최상단 노드 7을 기준으로 방문하지 않은 인접한 노드를 찾는다. (6, 8 노드) 6을 스택에 삽입 후 방문 처리
5. 6이 단말 노드 이므로, 6을 빼고 다시 7을 기준으로 방문하지 않는 인접한 노드를 찾는다. 8을 스택에 삽입 후 방문 처리
6. 더 이상 인접 노드가 없기에 8, 7, 2다시 빼내고, 1에 인접한 노드 3을 스택에 삽입 후 방문 처리한다.
7. 스택의 최상단 노드 3을 기준으로 방문하지 않은 인접한 노드를 찾는다. (4, 5 노드) 4을 스택에 삽입 후 방문 처리
8. 4와 인접한 노드 5을 스택에 삽입 후 방문 처리
노드의 탐색 순서는 1 -> 2 -> 7 -> 6 -> 8 -> 3 -> 4 -> 5

```python
def dfs(graph, n, visited):
  visited(n) = True
  print(n, end = ' ')

# 현재 노드와 다른 노드를 재귀를 통해 방문
  for i in graph[n]:
    if not visited[i]:
      dfs(graph, i, visited)

# 각 노드가 연결된 정보를 리스트 자료형으로 표현
graph = [

]

visited = [False] * 9

dfs(graph, 1, visited)
```

## BFS 너비 우선 탐색
가까운 노드부터 탐색
DFS(깊이 우선 탐색)는 최대한 멀리 있는 노드를 우선으로 탐색하는 방식으로 동작한다.
BFS는 반대 개념이다.
Queue 방식을 사용하여 구현한다.

구현하는 방법
1. 빈 큐를 생성
2. 탐색 시작 노드를 큐에 삽인한 후 방문 처리한다.
3. 큐에서 노드를 꺼내 해당 인접 노드 중에서 방문하지 않은 모든 노드를 모두 큐에 삽입한다. 그리고 나서 방문 처리(Queue 방식)
4. 3번 과정을 더 이상 수행할 수 없을 때까지 반복

먼저 공백 `Queue`를 생성
1 -> 2 -> 3 -> 8 -> 7 -> 4 -> 5 -> 6

```python
def bfs(graph, n, visited):
  visited(n) = True
  print(n, end = " ")
  nexts = []

  for i in graph[n]:
    if not visited[i]:
      visited[i] = True
      print(n, end = " ")
      nexts.append(i)
  bfs(graph, nexts, visited)

graph = []

visited = [Fasle] * 9
```

# 집합(그래프에서 아주 많이 활용하는 것)
순서 및 중복이 없는 원소들을 갖는 자료구조
예를 들어 A = {1, 6, 6, 6, 4, 3} ==> 집합으로 생각할 때
A = {1, 6, 4, 3} => 중복 제거
A = {6, 4, 1, 3} => 순서 X

### 집합은 특성에 따라 부르는 형태가 다양하게 존재
- 원소의 개수가 유한 => 유한 집합(반대 개념으로는 무한 집합)
- 아무런 원소를 가지고 있지 않으면 => 공집합
- 코테에서 출제되는 집합 => 상호베타적 집합(교집합이 없는 집합 관계)

교집합이란?
위의 상호배타적 집합을 사용하여 코딩하는
- 최소 신장 트리(노드의 개수가 간선의 개수보다 하나 작고, 순환이 안 됨)
- 네트워크
- 게임 개발

### 집합의 연산
집합은 트리로 표현하며 대표적인 연산 합치기와 탐색이 존재한다.

### 트리를 배열로 표현하기(빈 값이 생김) -> 인접 리스트 표현

### 표현
집합은 배열을 활용한 트리로 구현된다
**각각의 집합에는 대표 원소가 있어야 한다**

집합을 배열로 표현한다는 의미는 하나의 배열로 상호 배타적 관계를 가지는 집합을 모두 표현하게 된다
- **배열의 인덱스는 현재 노드의 값을 의미하고, 배열 값은 부모 노드를 의미한다.**

예를 들어보면 a[3] = 10
-> 노드 3의 부모 노드는 10이다.
루트 노드는 집합의 대표이므로 부모가 없다. 부모 노드가 자기 자신이다.
(루트 노드는 값 자체가 배열의 인덱스와 동일하다)

(배열의 인덱스는 0부터 시작하는데 집합을 배열로 표현할 때에는 0을 사용하지 않는다)

부모 노드의 값을 배열의 값으로 저장

현재 노드의 값을 배열의 인덱스로 활용

# 유니온-파인드 알고리즘
### 파인드 연산 
특정 노드와 루트 노드가 무엇인지 탐색하는 연산
(특징으로는 특정 노드가 같은 집합에 있는지 확인할 때 사용한다)



