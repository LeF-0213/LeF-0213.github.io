---
layout: post
related_posts:
    - /frontend/python
title:  "클래스(class)"
date:   2025-08-05
categories:
  - frontend
  - python
description: >
  클래스와 멤버 필드, 멤버 메서드 개념을 예시를 통한 이해
---
* toc
{:toc .large-only}

# 클래스(class)란?
* 클래스는 객체를 만들기 위한 템플릿 또는 설계도이다. 
* 클래스는 객체의 공통 속성과 동작을 정의하며, 객체를 생성하는데 사용된다. 
* 예를 들어, "자동차" 클래스는 모든 자동차 객체가 가져야 하는 속성(색상, 속도)과 메서드(주행, 멈춤)를 정의할 수 있다.

```python
class 클래스이름:
    # 클래스 속성(멤버 변수) 정의 (모든 인스턴스가 공유)
    속성1 = 초기값1
    속성2 = 초기값2

    # 생성자 메서드 (인스턴스 초기화, 생략 가능)
    def __init__(self, 매개변수1, 매개변수2, ...):
        # 인스턴스 속성 초기화
        self.속성1 = 매개변수1
        self.속성2 = 매개변수2

    # 메서드(멤버 함수) 정의
    def 메서드1(self, 매개변수1, 매개변수2, ...):
        # 메서드 동작 정의
        pass

    def 메서드2(self, 매개변수1, 매개변수2, ...):
        # 메서드 동작 정의
        pass
```
### 클래스 특징
* 파이썬에서 클래스를 정의하려면 `class` 키워드를 사용한다. 
* 클래스 이름은 관례적으로 대문자(PascalCase, 첫 글자 대문자)로 시작한다. 
* 클래스 내부에는 `속성(멤버 변수)`과 `메서드(멤버 함수)`를 정의할 수 있다.

| 용어 | 의미 | 비유 |
|:------:|------|------|
| **클래스** | 객체를 만드는 설계도 | 붕어빵 틀 |
| **객체** | 클래스로 만든 실체 | 붕어빵 |
| **인스턴스** | 특정 클래스로 만든 객체 | "붕어빵 틀로 만든 붕어빵" |

### 객체(Object)란?
* 객체는 현실 세계에서의 실제 개체나 추상적인 개념을 모델링한 것이다. 
* 예를 들어, 자동차, 사람, 은행 계좌 등이 객체가 될 수 있다. 
* 객체는 데이터(속성, 상태)와 메서드(동작, 함수)로 구성된다. 
* 클래스에서 만들어진 실제 존재하는 데이터(프로그램 내에서 사용된 것)

### 인스턴스(Instance)란?
* 클래스를 기반으로 실제로 생성된 객체를 인스턴스라고 한다. 
* 클래스는 여러 인스턴스를 생성할 수 있으며, 각 인스턴스는 독립적인 데이터와 메서드를 가진다. 
* 객체가 어떤 클래스에서 나왔는지에 초점을 맞출 때 사용하는 용어

### 속성(Attributes), 멤버 변수(Fields)
* 객체는 데이터를 저장하기 위한 속성을 가진다. 
* 이러한 속성은 객체의 상태나 특성을 나타내며 변수로 표현된다. 
* 예를 들어, 자동차 객체의 속성은 색상, 속도, 모델 등이 될 수 있다.

### 메서드(Methods), 멤버 함수(Functions)
* 객체는 데이터를 조작하거나 특정 작업을 수행하기 위한 메서드를 포함한다. 
* 이러한 메서드는 함수와 비슷하게 동작하지만, 객체의 상태에 접근하고 조작할 수 있다. 
* 자동차 객체의 메서드로는 주행, 정지, 경적 울리기 등이 있을 수 있다.

### 생성자(Constructor, __init__)
* 파이썬에서 생성자(Constructor)는 클래스의 인스턴스가 생성될 때 자동으로 호출되는 특별한 메서드이다. 
* 생성자는 객체의 초기화를 담당하며, 객체가 생성될 때 필요한 속성을 초기화하고 설정하는 역할을 한다. 
* 파이썬에서 생성자 메서드는 `__init__`라고 이름이 정해져 있다. 
* 속성은 `self`를 사용하여 접근하고 설정한다. 
* 이렇게 초기화된 속성은 객체가 생성될 때마다 다른 값을 가질 수 있습니다.

```python
class 클래스이름:
    def __init__(self, 매개변수1, 매개변수2):
        self.속성1 = 매개변수1
        self.속성2 = 매개변수2
```
**디폴트 생성자**

```python
class Dog:
  pass    # __init__ 없음

# 자동으로 빈 생성자가 만들어짐
sol = Dog() # 정상 작동
```
**참고**: `__init__`을 정의하지 않으면 Python이 자동으로 빈 생성자를 만든다.

## 클래스 생성과 인스턴스화
### 빈 클래스 생성

```python
class Dog:
  pass      # 내용이 없을 때 사용
```
### 객체(인스턴스) 생성
클래스를 정의한 후에는 이를 기반으로 객체(인스턴스)를 생성할 수 있다. 

```python
sol = Dog()

print(sol)        # <__main__.Dog object at 0x7a50f34ec710>
print(type(sol))  # <class '__main__.Dog'>
print(id(sol))    # 134488097998608

rucy = Dog()

print(rucy)       # <__main__.Dog object at 0x7a510036b320>
print(type(rucy)) # <class '__main__.Dog'>
print(id(rucy))   # 134488314524448
```

## 변수의 종류
### 클래스 변수
* 클래스 변수는 클래스에 속하는 변수로, 
* 클래스가 생성될 때 정의되며 그 클래스로 만들어진 모든 인스턴스(객체)들이 공유하는 변수이다. 
* 클래스 변수는 클**래스명으로 직접 접근하거나 인스턴스명으로 접근**할 수 있지만, 
* 모든 인스턴스가 같은 메모리 공간의 값을 참조하기 때문에 **한 인스턴스에서 값을 변경하면 다른 인스턴스에서도 변경**된 값을 볼 수 있다.
* 주로 전체 객체에 공통적인 속성을 저장할 때 사용한다.

### 클래스 변수(속성) 생성
Dog.name, Dog.age, Dog.family는 클래스 변수에 접근

```python
class Dog:
  name = '무명'
  age = 0
  family = '알 수 없음'

print(Dog.name)     # 무명
print(Dog.age)      # 0
print(Dog.family)   # 알 수 없음
```
### 인스턴스 변수
* 인스턴스 변수는 각 인스턴스(객체)마다 별도로 생성되는 변수로, 
* 객체를 만들 때마다 `self` 키워드를 통해 **생성자(__init__ 메서드)**에서 정의되며, 각 객체가 고유한 값을 따로 저장한다. 
* 인스턴스 변수는 **인스턴스명으로만 접근 가능**하며, 다른 인스턴스에 영향을 주지 않고 자신만의 데이터를 가질 수 있어 **객체마다 다른 속성값을 저장할 때 사용**된다.

**Dog 클래스 생성**

```python
class Dog:
  def __init__(self, name, age, family='족보없음'):
    self.name = name
    self.age = age
    self.family = family
```
**인스턴스 객체 생성**

```python
sol = Dog('솔', 9, '말티푸') # 생성자 초기화
print(sol)        # <__main__.Dog object at 0x7a50e7cb2ea0>
print(sol.name)   # 솔
print(sol.age)    # 9
print(sol.family) # 말티푸
```
### 인스턴스 변수 생성
* 인스턴스에 같은 이름의 인스턴스 변수가 없으면 → 클래스 변수에서 값을 찾음
* 인스턴스 변수에 같은 이름이 생기면 → **인스턴스 변수가 우선적으로 사용**됨
* 출력값은 클래스 변수의 값이 보이는 것이지만,
* 클래스 변수의 값을 변경하는 것이 아니라
* 인스턴스 변수라는 **"같은 이름의 새로운 변수"**를 인스턴스에 추가하는 것

```python
sol = Dog() # 인스턴스 변수 생성

sol.name = "솔"
sol.age = 9
sol.family = '말티푸'

print(sol.name)    # 솔
print(sol.age)     # 9
print(sol.family)  # 말티푸
```
## 변수 우선 순위

```python
class Dog:
  name = '무명'   # 클래스 변수

  def __init__(self, name):
    self.name = name # 인스턴스 변수

sol = Dog('솔')

# 우선순위: 인스턴스 변수 > 클래스 변수
print(sol.name)   # 솔 (인스턴스 변수)
print(Dog.name)   # 무명 (클래스 변수)

# 인스턴스 변수 삭제하면?
del sol.name
print(sol.name)   # 무명 (클래스 변수로 찾음)
```
**우선 순위**: 인스턴스 변수 -> 클래스 변수 -> AttributeError

## 메서드 타입
### 인스턴스 메서드(Instance Method)
* 인스턴스를 통해 호출되며, `self`를 첫 번째 매개변수로 받는다.
* `self`로 인스턴스 변수/ 메서드 접근한다.
* 객체의 상태를 조작하거나 객체에 특정 작업을 수행하는 메서드이다. 
* 대부분의 클래스 메서드는 인스턴스 메서드이다. 
* `\_\_init\_\_` 메서드도 인스턴스 메서드이다.
* 인스턴스를 통해 호출한다.

```python
class Dog:
  def __init__(self, name, age):
    self.name = name    # 인스턴스 변수
    self.age = age

  def bark(self):       # 인스턴스 메서드
    return f'{self.name}: 멍멍!'

  def get_info(self):   # 인스턴스 메서드
    return f'{self.name}는 {self.age}살 입니다.'

  def birthday(self):   # 인스턴스 메서드
    self.age += 1       # 인스턴스 변수 수정
    return f"{self.name}이가 {self.age}살이 되었습니다!"

# 사용
sol = Dog('솔', 8)
print(sol.bark())       # 솔: 멍멍!
print(sol.get_info())   # 솔는 8살입니다
print(sol.birthday())   # 솔이가 9살이 되었습니다!
```

### 클래스 메서드(Class Method)
* 클래스 레벨에서 동작하며, 모든 인스턴스가 공유하는 메서드이다. 
* 클래스 메서드는 `@classmethod` 데코레이터를 사용하여 정의하며, 
* 첫 번째 매개변수로 `cls`를 사용한다.
* 클래스 변수에 접근 가능하다.
* 인스턴스 생성 없이 호출 가능하다.
* `cls`는 현재 클래스 자체를 가리킨다.

```python
class Character:
  total_characters = 0 # 클래스 변수

  def __init__(self, name, hp, attack, defense):
    self.name = name
    self.hp = hp
    self.attack = attack
    self.defense = defense

  @classmethod
  def create_warrior(cls, name):  # 클래스 메서드
    return cls(name, hp=100, attack=15, defense=20)

  @classmethod
  def create_mage(cls, name):     # 클래스 메서드
    return cls(name, hp=60, attack=25, defense=5)

  @classmethod
  def create_archer(cls, name):   # 클래스 메서드
    return cls(name, hp=80, attack=20, defense=10)

  @classmethod
    def get_total_characters(cls):  # 클래스 메서드
        return f"총 {cls.total_characters}명의 캐릭터가 생성되었습니다"

  def __str__(self):
    return f'{self.name} | HP:{self.hp} ATK:{self.attack} DEF:{self.defense}'

# 직업별 캐릭터 생성
warrior = Character.create_warrior('전사')
mage = Character.create_mage('마법사')
archer = Character.create_archer('궁수')

print(warrior)    # 전사 | HP:100 ATK:15 DEF:20
print(mage)       # 마법사 | HP:60 ATK:25 DEF:5
print(archer)     # 궁수 | HP:80 ATK:20 DEF:10

# 클래스 메서드로 총 개수 확인
print(Character.get_total_characters()) # 총 3명의 캐릭터가 생성되었습니다
```
#### cls vs self

| 구분 | `cls` | `self` |
|------|------|-------|
| 사용처 | `@classmethod` | 인스턴스 메서드 |
| 의미 | 클래스 자체 | 인스턴스 자체 |
| 호출 | `Class.method()` | `instance.method()` |
| 반환 가능 | 새 인스턴스 생성 가능 | 자기 자신 수정 |

### 정적 메서드(Static Mehtod)
* 특정 클래스나 인스턴스와 관련이 없는 메서드로, 
* 클래스 내부에 정의되어 있지만 **클래스나 인스턴스와 독립적으로 호출**될 수 있다. 
* 정적 메서드는 `@staticmethod` 데코레이터를 사용하여 정의한다.
* `self`나 `cls` 매개변수가 없다.
* 유틸리티 함수로 사용한다.
* 클래스의 네임스페이스에 속하지만 독립적이다.

```python
class Validator
  @staticmethod
  def is_valid_email(email):
    # 이메일 형식 검사
    return '@' in email and '.' in email.split('@')[1]

  @staticmethod
  def is_valid_phone(phone):
    # 전화번호 형식 검사(010-0000-0000)
    parts = phone.split('-')
    if len(parts) != 3:
      return False
    return len(parts[0]) == 3 and len(parts[1]) == 4 and len(parts[2]) == 4

  @staticmethod
  def is_valid_password(password):
    # 비밀번호 강도 검사 (8자 이상)
    return len(password) >= 8

# 사용
print(Validator.is_valid_email("test@example.com"))  # True
print(Validator.is_valid_email("invalid-email"))     # False
print(Validator.is_valid_phone("010-1234-5678"))     # True
print(Validator.is_valid_phone("010-12-3456"))       # False
print(Validator.is_valid_password("password123"))    # True
print(Validator.is_valid_password("short"))          # False
```

| 메서드 타입 | 데코레이터 | 첫 번째 매개변수 | 접근 가능 | 호출 방법 |
|--------------|-------------|------------------|------------|-------------|
| **인스턴스 메서드** | 없음 | `self` | 인스턴스 변수/메서드 | `instance.method()` |
| **클래스 메서드** | `@classmethod` | `cls` | 클래스 변수/메서드 | `Class.method()` |
| **정적 메서드** | `@staticmethod` | 없음 | 제한적 | `Class.method()` |

## 선택 가이드
**핵심**: 상황에 맞는 메서드 타입을 선택하면 코드가 더 명확하고 유지보수하기 쉬워진다.

### 언제 인스턴스 메서드?
* 객체의 상태(인스턴스 변수)를 사용하거나 변경할 때
* 객체마다 다른 동작이 필요할 때
* 대부분의 일반적인 메서드

### 언제 클래스 메서드?
* 팩토리 메서드(다양한 방식으로 객체 생성)
* 클래스 변수를 조작할 때
* 대체 생성자가 필요할 때

### 언제 정적 메서드?
* 클래스/인스턴스 변수가 필요 없을 때
* 유틸리티 함수로 사용할 때
* 클래스와 논리적으로 관련되지만 독립적인 함수